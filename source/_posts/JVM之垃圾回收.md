---
title: JVM之垃圾回收
date: 2018-10-31 20:02:12
tags:
    - JVM
    - GC
---

# 概述

垃圾回收需要解决的问题有三个:

1. 如何确定对象不再被引用
2. 确定垃圾对象之后什么时候进行清理
3. 采取什么清理策略



# 垃圾对象定位

垃圾对象定位是垃圾回收的第一步, 只有在确定垃圾对象之后, 我们才能进行回收.



## 引用计数法

每一个对象都有一个标志位, 用于记录被引用的次数. 当次数为0时表示对象不再被使用, 那么就可以标记为垃圾对象.

### 优点

1. 简单
2. 快速

### 缺点

1. 无法解决循环引用的问题

## 可达性分析算法

在对象组成的图中, 每一个对象必须和关键的节点(ROOT)是连通的, 这样才能认为对象是存活的.



# 垃圾清除算法

垃圾清除算法就是把垃圾对象从内存中删除, 我们可以抽象的把垃圾清除的过程的认为是: 从一个数组中删除一部分元素.

## 直接删除法

把数组中的元素直接删除

删除之前:

[✔✔✔✔✔✔✔✔✔✔✔✔✔✔✔✔]

删除之后:

[✔✔□□□✔✔□✔✔✔□□□✔✔✔]



可以很明显的发现内存的碎片化, 所以这个算法是不可接收的



## 复制算法

在复制算法中, 需要有两个相同大小的内存块, 需要删除元素时, 把需要保留的元素复制到另外一个内存中

这个算法除了空间复杂度有点大之外没什么缺点.

适用于存活对象少的情况, 这种情况下复制次数少



## 整理算法

删除元素之后把内存整理一下, 就是我们常见的数组删除算法, 适用于存活对象多的情况.



## STW

当需要触发GC时, 所有的线程必须中断才能准确的进行垃圾检测. 所以JVM在需要进行GC的时候会设置一个标志位, 所有的线程都会轮询这个标志位, 当发现需要进行GC的时候, 由线程自己进行中断, 当所有的线程都中断时, 也就发生了STW事件(除了垃圾回收线程之外没有线程在运行了).



# 垃圾清除算法实现



1. 并发垃圾收集器: 可以和用户线程一起运行的垃圾收集器
2. 并行垃圾收集器: 可以使用多核的垃圾收集器
3. 单体垃圾收集器: 一次性完成垃圾收集工作
4. 渐进式垃圾收集器: 垃圾收集的过程分为多个步骤
5. 保守垃圾收集器: 无法完全收集全部垃圾
6. 准确垃圾收集: 可以完全收集垃圾
7. 安全点: 线程执行过程中可以确定所有的栈上对象引用, 可以保证垃圾回收器准确运行



## 垃圾清除算法的一般原则

1. 年轻代通常使用单体(STW)的复制(对象存活几率小)垃圾回收算法.
2. 老年代通常使用标记清除压缩算法, 对象存活率高. 通常是渐进式的垃圾回收算法.
   1. 并发标记: 和用户线程一起工作(用户可能产生新的垃圾), 在第一遍工作结束之后, 可能需要再次检查一下
   2. 渐进式压缩碎片: 把内存分为不同的区域, 找到被引用最少的区域, 然后压缩
3. **垃圾回收只能被延迟, 不能被取消**









