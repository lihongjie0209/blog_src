---
title: OS之并发
date: 2018-08-08 20:28:48
tags:
    - 操作系统
---



问: 什么需要并发?

>  答: 速度快

---

问: 并发需要面对的问题是什么?

> 答: 确保程序的正确性.

---

问: 什么影响了程序的正确性 ?

> 答: 线程之间共享可写资源, 如内存 文件系统

---



问: 多进程之间会有这个正确性的问题吗 ?

> 答: 视情况, 判断的关键是二者之间是否有共享可写资源.

---

问: 如何解决正确性的问题 ?

> 答: 不共享: 每个线程都有自己的拷贝资源, 或者是在写共享资源时不可被中断; 不可写: 只读资源可以共享访问.

---

问: 如何实现不可被中断?

> 答: 锁, 哪怕被中断, 其他线程也因为没有锁而取消执行

---

问: 如何协调多个线程之间的调度 ?

>  答: 这本身是一个线程沟通的问题, 线程之间必须有沟通才能协商调度. 锁可以认为是最基础的一个沟通方式, 告诉其他线程共享资源是否在使用, 但是这种方式太基础了,无法满足复杂的需求.

---

问: 那么条件变量也是共享可写资源?

> 答: 是的, 所以只可以在一个线程持有锁的时候才能使用条件变量.

---

问: 如何实现一个锁?

>  答:  锁的目的是当操作系统进行线程切换时程序员可以进行一定的调度(程序员承担一部分系统调度的责任)
>
> | 实现方式                | 优点                                           | 缺点                         |
> | ----------------------- | ---------------------------------------------- | ---------------------------- |
> | 禁止操作系统切换进程    | 简单                                           | 只在单核系统中有用, 权限问题 |
> | 轮询                    | 简单, 多核可用                                 | 性能问题                     |
> | 休眠等待队列(计数器为1) | 不需要轮询, 性能好, 可以控制下一个锁的获得线程 |                              |
> | 休眠等待队列 + 计数器   | 更加灵活                                       |                              |

---

问: 如何实现一个条件变量 ?

> 答: 和实现锁一样, 只是把锁的状态改为条件变量的条件.

---

问: 为什么需要在多线程的代码中使用while 而不是 if ?

---

>  答:  while 比 if 多循环一次, 可以避免在条件判断之后进行线程切换导致条件不满足, 但是程序无法继续判断.



---

问: 多线程下常见的BUG有哪些?

> 答: 
>
> | BUG                    | 描述                                                         | 解决                                                         |
> | ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | 共享可写资源访问不上锁 |                                                              | 互斥访问共享资源                                             |
> | 线程之间调度靠运气     |                                                              | 条件变量进行调度                                             |
> | 死锁                   | 1. 互斥访问<br />2. 持有一个锁, 等待一个锁<br />3. 被持有的锁无法释放<br />4. 环形等待 | 1. 使用全局唯一的获取锁的顺序避免环形等待.<br />2. 使用tryLock释放锁 |