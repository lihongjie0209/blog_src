---
title: OS之进程
date: 2018-08-05 10:33:48
tags:
    - 操作系统
---


问: 什么是进程?

答: 运行中的程序.

问: 什么是程序?

答: 储存在磁盘中的二进制文件.

问: 进程由什么组成?

答: 内存, 进程运行时需要对内存进行读写才能保持自己的状态.

问: 进程还由什么组成?

答: CPU寄存器, 也是内存的一种, 不过是CPU专用的高速内存.

问: 进程还由什么组成?

答: IO设备, 常见的有硬盘.

问: 程序是如何从硬盘加载到内存中的?

![](http://liimg.oss-cn-shenzhen.aliyuncs.com/18-8-5/18178959.jpg)

问: 进程有哪些状态?

![](http://liimg.oss-cn-shenzhen.aliyuncs.com/18-8-5/62406262.jpg)

问: 操作系统如何控制进程?

答: 通过代理, 对系统资源的操作必须通过操作系统(kernel mode)的系统调用.

问: 系统调用是如何实现的?

答: 通过软中断.

问: 什么是中断?

答: 操作系统事件.

问: 操作系统如何重新获得控制权?

答: 乐观: 等待进程放弃执行  悲观: 定时强制切换到操作系统控制

问: 进程是如何切换的? 

答: 进程的组成是有两部分: 静态的代码和数据 + 动态的运行状态(内存 + 寄存器), 只要能保存并恢复运行状态, 那么进程就可以切换.


问: 进程的调度算法有哪些?

答: 最简单的调度算法是FIFO, 使用队列进行调度.

问: FIFO调度算法有什么缺点, 造成这个缺点的原因是什么?

答: 如果队列中有一个任务运行时间过长, 那么会导致这个任务的之后的所有任务得不到运行(饥饿).

造成这个问题的主要原因是: 长任务的优先级过高.


问: 如何解决短任务的饥饿问题?

答: 使用优先队列, 短任务优先.


问: 短任务优先有什么缺点?

答: 所有的任务必须提前规划好才可以(预测能力), 但这个是不现实的.

![](http://liimg.oss-cn-shenzhen.aliyuncs.com/18-8-5/90178355.jpg)

问: 上述两个基于队列的算法不合适的本质原因是什么?

1. 队列的基本元素是以任务为单位的, 一个任务一旦开始执行就无法再次调度.
2. 调度器是静态的, 只能预先把任务规划好.


问: 还有什么调度算法?

答: RR, 循环队列, 队列中的每一个任务都运行一定的时间片, 然后切换. 这个算法的优点是:

  1. 动态, 新的任务入队马上就可以得到时间片.
  2. 把时间片作为可调度的资源, 而不是按照任务分配

问: RR有什么缺点?

答: 对于单个任务来说, 完成的时间变长了. 因为时间片要轮转.

问: 还有什么调度算法?

答: 多级反馈队列调度算法, 这个算法有多个队列, 每个队列有不同的优先级, 当任务开始进入调度器时, 优先级最高, 当任务在时间片内还没有执行完毕, 那么就移动到下一个优先级队列(后台任务); 如果任务在当前时间片内主动放弃CPU, 那么保持在当前队列(和用户交互的任务).

![](http://liimg.oss-cn-shenzhen.aliyuncs.com/18-8-5/99088326.jpg)

![](http://liimg.oss-cn-shenzhen.aliyuncs.com/18-8-5/73807220.jpg)


问: 多级反馈队列调度算法有什么缺点?

答: 当用户主动放弃CPU时, 任务的优先级保持不变. 用户可以编写恶意程序主动放弃CPU确保他的程序一直在最高优先级. 而且只要最高优先级有任务, 那么低优先级队列就无法得到时间片, 所以需要操作系统隔一段时间之后把所有的任务都提升到最高优先级队列.


